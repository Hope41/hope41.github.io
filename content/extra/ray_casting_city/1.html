<!DOCTYPE html>
    <head>
        <style>
            body {
                background: #fff;
                margin: 0;
                overflow: hidden
            }
        </style>
    </head>
    <body>
        <script>
            'use strict'
            class Map {
                constructor(width, height) {
                    this.array = []
                    for (let i = 0; i < width * height; i ++) this.array.push(0)

                    this.width = width
                    this.height = height
                }

                generate() {
                    for (let i = 0; i < this.width * this.height; i ++) {
                        const I = i % this.width

                        if (i % (this.width * 2) < this.width && I % 2 == 0) {
                            this.array[i] = 1

                            if (i % (this.width * 4) < this.width && I % 4 == 0 ||
                                (i + this.width * 2) % (this.width * 4) < this.width &&
                                (I + 2) % 4 == 0) {
                                    const dir = random(0, 4)

                                    if (!dir) this.array[i-this.width] = 1
                                    if (dir == 1) this.array[i+1] = 1
                                    if (dir == 2) this.array[i+this.width] = 1
                                    if (dir == 3) this.array[i-1] = 1
                            }
                        }


                        if (I == 0 || I == this.width - 1 || 
                            i < this.width || i > this.height * this.width - this.width)
                                this.array[i] = 1
                    }
                }

                update() {
                    hero.update()

                    ctx.fillStyle = '#666'
                    this.array.forEach((item, index) => {
                        if (item) {
                            const pos = indexToPos(index, this.width)
                            ctx.strokeRect(
                                pos.x * scale,
                                pos.y * scale,
                                scale,
                                scale
                            )
                        }
                    })
                }
            }

            class Player {
                constructor(x, y) {
                    this.x = x
                    this.y = y
                    this.width = .3
                    this.height = .3

                    this.angle = 0
                }

                update() {
                    this.angle ++
                    this.draw()
                }

                draw() {
                    ctx.save()
                        translate(
                            .5, .5, this
                        )
                        rotate(this.angle)

                        for (let i = 0; i < ray_amount; i ++) {
                            const increment = fov / ray_amount
                            const angle = i * increment - fov / 2

                            ctx.strokeStyle = '#00f'
                            line(
                                0, 0, cos(angle) * view_max,
                                sin(angle) * view_max, .1
                            )

                            ctx.stroke()
                        }
                    ctx.restore()
                }
            }

            function rotate(angle) {
                return ctx.rotate(angle * Math.PI / 180)
            }

            function cos(angle) {
                return Math.cos(angle * Math.PI / 180)
            }

            function sin(angle) {
                return Math.sin(angle * Math.PI / 180)
            }

            function indexToPos(index, width) {
                return {
                    x: index % width,
                    y: ~~(index / width)
                }
            }

            function posToIndex(x, y, width) {
                return Math.floor(x) + Math.floor(y) * width
            }

            function translate(x, y, obj) {
                x = x * obj.width
                y = y * obj.height
                return ctx.translate(
                    (x + obj.x) * scale,
                    (y + obj.y) * scale
                )
            }

            function line(x1, y1, x2, y2, width = 0) {
                ctx.beginPath()
                ctx.lineWidth = (width ? width * scale : 1)
                ctx.moveTo(
                    x1 * scale,
                    y1 * scale
                )
                ctx.lineTo(
                    x2 * scale,
                    y2 * scale
                )
                ctx.stroke()
            }

            function setBlockSize() {
                const screen_division = 1
                return cvs.height / screen_division / map.height
            }

            function random(min, max, int = 1) {
                const value = Math.random() * (max - min) + min

                return int ? Math.floor(value) : value
            }

            function resize() {
                cvs.width = innerWidth
                cvs.height = innerHeight

                scale = setBlockSize()
            }

            function update() {
                ctx.clearRect(0, 0, cvs.width, cvs.height)
                time ++

                map.update()

                requestAnimationFrame(update)
            }

            const cvs = document.createElement('canvas')
            const ctx = cvs.getContext('2d')
            const map = new Map(10, 10)
            const hero = new Player(5.4, 5.4)

            const view_max = 5
            const ray_accuracy = .02
            const ray_amount = 1
            const fov = 100

            let scale = setBlockSize()
            let time = 0

            document.body.appendChild(cvs)
            map.generate()

            addEventListener('resize', resize)
            resize()

            update()
        </script>
    </body>
</html>