<!DOCTYPE html>
    <head>
        <meta charset = utf-8>
        <meta name = viewport content = 'width = device-width, initial-scale = 1'>

        <script async src = 'https://www.googletagmanager.com/gtag/js?id=G-2MDQ9F697V'></script>
        <script src = /js/analytics.js></script>
        <script src = /js/highlight.min.js></script>
        <script src = /js/main.js></script>

        <title>Joachim Ford</title>

        <link rel = stylesheet href = /main.css>
        <link href = /fontawesome/css/fontawesome.css rel = stylesheet>
        <link href = /fontawesome/css/solid.css rel = stylesheet>
        <link href = /fontawesome/css/brands.css rel = stylesheet>
    </head>

    <body>
        <section class = topnav>
            <div>
                <a class = text href = '/'>JoachimFord.uk</a>
                <i class = 'fa-solid fa-bars' onclick = bar()></i>
                <a class = text href = /games>Games</a>
                <a class = text href = /articles>Articles</a>
                <a class = text href = /experiments>Experiments</a>
                <a href = https://github.com/Hope41 target = _blank><i class = 'fa-brands fa-github'></i></a>
                <a href = mailto:contact@joachimford.uk><i class = 'fa-solid fa-envelope'></i></a>
            </div>
        </section>

        <section class = main>
            <h1>Ray-casting City</h1>
            <div class = image id = ../images/ray_casting_city_big.png>things/ray_casting_city.html</div>
            <p></p>
            <script type = text id = html><!DOCTYPE html>
    <head>
        <meta charset = utf-8>
        <title>Ray-casting City</title>
        <style>
            body {
                background: #fff;
                margin: 0;
                overflow: hidden
            }
        </style>
    </head>
    <body>
        <script>
            'use strict'
            class Map {
                constructor(width, height) {
                    this.array = []
                    for (let i = 0; i < width * height; i ++) this.array.push(0)

                    this.width = width
                    this.height = height
                }

                generate() {
                    for (let i = 0; i < this.width * this.height; i ++) {
                        /* 'I' starts at zero at the start
                        of a row, and changes to the world width
                        at the end of the row */
                        const I = i % this.width

                        /* draw a grid of blocks with a
                        space padding around each one */
                        if (i % (this.width * 2) < this.width && I % 2 == 0) {
                            this.array[i] = 1

                            /* make sure 'i' is nowhere
                            near the sides of the world */
                            if (i % (this.width * 4) < this.width && I % 4 == 0 ||
                                (i + this.width * 2) % (this.width * 4) < this.width &&
                                (I + 2) % 4 == 0) {

                                    /* choose a random direction for every
                                    other block (up/down/left/right) and then
                                    duplicate a block next to it based on
                                    the direction. */
                                    const dir = random(0, 4)

                                    if (!dir) this.array[i-this.width] = 1
                                    if (dir == 1) this.array[i+1] = 1
                                    if (dir == 2) this.array[i+this.width] = 1
                                    if (dir == 3) this.array[i-1] = 1
                            }
                        }

                        /* add borders */
                        if (I == 0 || I == this.width - 1 || 
                            i < this.width || i > this.height * this.width - this.width)
                                this.array[i] = 1
                    }
                }

                update() {
                    hero.update()
                }
            }

            class Player {
                constructor(x, y) {
                    this.x = x
                    this.y = y
                    this.width = .3
                    this.height = .3

                    this.angle = 0
                    this.speed_x = 0
                    this.speed_y = 0

                    this.rot_speed = 5
                    this.forward_damping = 700
                    this.backward_damping = 900
                    this.momentum = .95
                }

                update() {
                    let dir = 1

                    this.x += this.speed_x
                    this.y += this.speed_y

                    if (key.arrowup || key.w || key.z) {
                        this.speed_x += cos(this.angle) / this.forward_damping
                        this.speed_y += sin(this.angle) / this.forward_damping
                    }
                    if (key.arrowdown || key.s) {
                        this.speed_x -= cos(this.angle) / this.backward_damping
                        this.speed_y -= sin(this.angle) / this.backward_damping

                        dir = -1
                    }

                    const rot_speed = this.rot_speed * (
                        Math.abs(this.speed_x) +
                        Math.abs(this.speed_y)
                    ) * 10

                    if (key.arrowleft || key.a || key.q)
                        this.angle -= rot_speed * dir
                    if (key.arrowright || key.d)
                        this.angle += rot_speed * dir

                    this.speed_x *= this.momentum
                    this.speed_y *= this.momentum

                    const merge = (x, y) => {
                        if (map.array[x + y * map.width]) {
                            const margin = {
                                left: (this.x + this.width) - x,
                                right: this.x - (x + 1),
                                top: (this.y + this.height) - y,
                                bottom: this.y - (y + 1)
                            }

                            const smallest_x_margin =
                                Math.abs(margin.left) < Math.abs(margin.right) ? margin.left : margin.right
                            const smallest_y_margin =
                                Math.abs(margin.top) < Math.abs(margin.bottom) ? margin.top : margin.bottom

                            if (Math.abs(smallest_x_margin) < Math.abs(smallest_y_margin))
                                this.speed_x -= smallest_x_margin
                            else
                                this.speed_y -= smallest_y_margin
                        }
                    }

                    merge(Math.floor(this.x), Math.floor(this.y))
                    merge(Math.floor(this.x + this.width), Math.floor(this.y + this.height))
                    merge(Math.floor(this.x + this.width), Math.floor(this.y))
                    merge(Math.floor(this.x), Math.floor(this.y + this.height))

                    this.draw()
                }

                draw() {
                    for (let i = 0; i < ray_amount; i ++) {
                        const increment = fov / ray_amount
                        const angle = i * increment - fov / 2

                        const length = getLengthOnMap(
                            angle + hero.angle,
                            hero.x + hero.width / 2,
                            hero.y + hero.height / 2,
                            view_max
                        )

                        const height = ((50 / length) * cvs.width) / 600
                        const shade = 50 / length

                        const dist_camera_height = height * camera_height
                        const dist_house_height = height * house_height

                        const segment_width = Math.floor(cvs.width / ray_amount) + 1
                        const divisions = 7

                        ctx.fillStyle = rgb(
                            shade,
                            shade,
                            shade / 2,
                            (view_max - length) * 50
                        )
                        ctx.fillRect(
                            i * segment_width,
                            cvs.height / 2 + dist_camera_height,
                            segment_width,
                            -dist_house_height
                        )

                        for (let n = 0; n < divisions; n ++) {
                            ctx.fillStyle = rgb(
                                shade / 2,
                                shade / 2,
                                shade / 5,
                                (view_max - length) * 50
                            )
                            ctx.fillRect(
                                i * segment_width,
                                cvs.height / 2 + dist_camera_height - (n * (dist_house_height / divisions)),
                                segment_width,
                                -dist_house_height / (divisions * 2)
                            )
                        }
                    }
                }
            }
            
            function getLengthOnMap(angle, start_x, start_y, max_look = 0) {
                let length = 0

                for (let i = 0; i < max_look; i += ray_accuracy) {
                    length += ray_accuracy

                    const x = start_x + cos(angle) * length
                    const y = start_y + sin(angle) * length

                    const block = map.array[posToIndex(x, y, map.width)]

                    if (block) return i
                }

                return max_look
            }

            function collide(obj1, obj2) {
                return (
                    obj1.x < obj2.x + obj2.width &&
                    obj1.x + obj1.width > obj2.x &&
                    obj1.y < obj2.y + obj2.height &&
                    obj1.y + obj1.height > obj2.y
                )
            }

            function rotate(angle) {
                return ctx.rotate((angle % 360) * Math.PI / 180)
            }

            function cos(angle) {
                return Math.cos(angle * Math.PI / 180)
            }

            function sin(angle) {
                return Math.sin(angle * Math.PI / 180)
            }

            function indexToPos(index, width) {
                return {
                    x: index % width,
                    y: ~~(index / width)
                }
            }

            function posToIndex(x, y, width) {
                return Math.floor(x) + Math.floor(y) * width
            }

            function rgb(red, green, blue, alpha = 255) {
                return `rgb(${red}, ${green}, ${blue}, ${alpha / 255})`
            }

            function random(min, max, int = 1) {
                const value = Math.random() * (max - min) + min

                return int ? Math.floor(value) : value
            }

            function resize() {
                cvs.width = innerWidth
                cvs.height = innerHeight
            }

            function update() {
                ctx.clearRect(0, 0, cvs.width, cvs.height)
                time ++

                map.update()

                requestAnimationFrame(update)
            }

            const cvs = document.createElement('canvas')
            const ctx = cvs.getContext('2d')

            let time = 0

            const key = {
                arrowup: false,
                arrowdown: false,
                arrowleft: false,
                arrowright: false,
                w: false,
                s: false,
                a: false,
                d: false,
                z: false,
                s: false,
                q: false,
                d: false
            }
            const view_max = 5
            const ray_accuracy = .03
            const camera_height = 1
            const house_height = 8
            const ray_amount = Math.floor(cvs.width / 2)
            const fov = 100

            const map = new Map(1000, 1000)
            const hero = new Player(1, 1)
            document.body.appendChild(cvs)
            map.generate()

            addEventListener('resize', resize)
            addEventListener('keydown', e => {
                if (key[e.key.toLowerCase()] != undefined)
                    key[e.key.toLowerCase()] = true
            })
            addEventListener('keyup', e => {
                if (key[e.key.toLowerCase()] != undefined)
                    key[e.key.toLowerCase()] = false
            })
            resize()

            update()
        <&sol;script>
    </body>
</html>
            </script>

            <script type = text id = html><!DOCTYPE html>
    <head>
        <style>
            body {
                background: #fff;
                margin: 0;
                overflow: hidden
            }
        </style>
    </head>
    <body>
        <script>
            'use strict'
            class Player {
                constructor(x, y) {
                    this.x = x
                    this.y = y
                    this.width = .3
                    this.height = .3

                    this.angle = 0
                }

                update() {
                    this.angle ++
                    this.draw()
                }

                draw() {
                    ctx.save()
                        translate(
                            .5, .5, this
                        )
                        rotate(this.angle)

                        for (let i = 0; i < ray_amount; i ++) {
                            const increment = fov / ray_amount
                            const angle = i * increment - fov / 2

                            ctx.strokeStyle = '#00f'
                            line(
                                0, 0, cos(angle) * view_max,
                                sin(angle) * view_max, .1
                            )

                            ctx.stroke()
                        }
                    ctx.restore()
                }
            }

            function rotate(angle) {
                return ctx.rotate(angle * Math.PI / 180)
            }

            function cos(angle) {
                return Math.cos(angle * Math.PI / 180)
            }

            function sin(angle) {
                return Math.sin(angle * Math.PI / 180)
            }

            function indexToPos(index, width) {
                return {
                    x: index % width,
                    y: ~~(index / width)
                }
            }

            function posToIndex(x, y, width) {
                return Math.floor(x) + Math.floor(y) * width
            }

            function translate(x, y, obj) {
                x = x * obj.width
                y = y * obj.height
                return ctx.translate(
                    (x + obj.x) * scale,
                    (y + obj.y) * scale
                )
            }

            function line(x1, y1, x2, y2, width = 0) {
                ctx.beginPath()
                ctx.lineWidth = (width ? width * scale : 1)
                ctx.moveTo(
                    x1 * scale,
                    y1 * scale
                )
                ctx.lineTo(
                    x2 * scale,
                    y2 * scale
                )
                ctx.stroke()
            }

            function setBlockSize() {
                const screen_division = 1
                return cvs.height / screen_division / height
            }

            function random(min, max, int = 1) {
                const value = Math.random() * (max - min) + min

                return int ? Math.floor(value) : value
            }

            function resize() {
                cvs.width = innerWidth
                cvs.height = innerHeight

                scale = setBlockSize()
            }

            function update() {
                ctx.clearRect(0, 0, cvs.width, cvs.height)
                time ++
                hero.update()

                requestAnimationFrame(update)
            }

            const cvs = document.createElement('canvas')
            const ctx = cvs.getContext('2d')
            const hero = new Player(5.4, 5.4)

            const view_max = 5
            const ray_amount = 1
            const fov = 100

            const width = 10
            const height = 10

            let scale = setBlockSize()
            let time = 0

            document.body.appendChild(cvs)

            addEventListener('resize', resize)
            resize()

            update()
        <&sol;script>
    </body>
</html>
            </script>

            <script type = text id = html><!DOCTYPE html>
    <head>
        <style>
            body {
                background: #fff;
                margin: 0;
                overflow: hidden
            }
        </style>
    </head>
    <body>
        <script>
            'use strict'
            class Map {
                constructor(width, height) {
                    this.array = []
                    for (let i = 0; i < width * height; i ++) this.array.push(0)

                    this.width = width
                    this.height = height
                }

                generate() {
                    for (let i = 0; i < this.width * this.height; i ++) {
                        const I = i % this.width

                        if (i % (this.width * 2) < this.width && I % 2 == 0) {
                            this.array[i] = 1

                            if (i % (this.width * 4) < this.width && I % 4 == 0 ||
                                (i + this.width * 2) % (this.width * 4) < this.width &&
                                (I + 2) % 4 == 0) {
                                    const dir = random(0, 4)

                                    if (!dir) this.array[i-this.width] = 1
                                    if (dir == 1) this.array[i+1] = 1
                                    if (dir == 2) this.array[i+this.width] = 1
                                    if (dir == 3) this.array[i-1] = 1
                            }
                        }


                        if (I == 0 || I == this.width - 1 || 
                            i < this.width || i > this.height * this.width - this.width)
                                this.array[i] = 1
                    }
                }

                update() {
                    hero.update()

                    ctx.fillStyle = '#666'
                    this.array.forEach((item, index) => {
                        if (item) {
                            const pos = indexToPos(index, this.width)
                            ctx.strokeRect(
                                pos.x * scale,
                                pos.y * scale,
                                scale,
                                scale
                            )
                        }
                    })
                }
            }

            class Player {
                constructor(x, y) {
                    this.x = x
                    this.y = y
                    this.width = .3
                    this.height = .3

                    this.angle = 0
                }

                update() {
                    this.angle ++
                    this.draw()
                }

                draw() {
                    ctx.save()
                        translate(
                            .5, .5, this
                        )
                        rotate(this.angle)

                        for (let i = 0; i < ray_amount; i ++) {
                            const increment = fov / ray_amount
                            const angle = i * increment - fov / 2

                            ctx.strokeStyle = '#00f'
                            line(
                                0, 0, cos(angle) * view_max,
                                sin(angle) * view_max, .1
                            )

                            ctx.stroke()
                        }
                    ctx.restore()
                }
            }

            function rotate(angle) {
                return ctx.rotate(angle * Math.PI / 180)
            }

            function cos(angle) {
                return Math.cos(angle * Math.PI / 180)
            }

            function sin(angle) {
                return Math.sin(angle * Math.PI / 180)
            }

            function indexToPos(index, width) {
                return {
                    x: index % width,
                    y: ~~(index / width)
                }
            }

            function posToIndex(x, y, width) {
                return Math.floor(x) + Math.floor(y) * width
            }

            function translate(x, y, obj) {
                x = x * obj.width
                y = y * obj.height
                return ctx.translate(
                    (x + obj.x) * scale,
                    (y + obj.y) * scale
                )
            }

            function line(x1, y1, x2, y2, width = 0) {
                ctx.beginPath()
                ctx.lineWidth = (width ? width * scale : 1)
                ctx.moveTo(
                    x1 * scale,
                    y1 * scale
                )
                ctx.lineTo(
                    x2 * scale,
                    y2 * scale
                )
                ctx.stroke()
            }

            function setBlockSize() {
                const screen_division = 1
                return cvs.height / screen_division / map.height
            }

            function random(min, max, int = 1) {
                const value = Math.random() * (max - min) + min

                return int ? Math.floor(value) : value
            }

            function resize() {
                cvs.width = innerWidth
                cvs.height = innerHeight

                scale = setBlockSize()
            }

            function update() {
                ctx.clearRect(0, 0, cvs.width, cvs.height)
                time ++

                map.update()

                requestAnimationFrame(update)
            }

            const cvs = document.createElement('canvas')
            const ctx = cvs.getContext('2d')
            const map = new Map(10, 10)
            const hero = new Player(5.4, 5.4)

            const view_max = 5
            const ray_accuracy = .02
            const ray_amount = 1
            const fov = 100

            let scale = setBlockSize()
            let time = 0

            document.body.appendChild(cvs)
            map.generate()

            addEventListener('resize', resize)
            resize()

            update()
        <&sol;script>
    </body>
</html>
            </script>

            <script type = text id = html><!DOCTYPE html>
                <head>
                    <style>
                        body {
                            background: #fff;
                            margin: 0;
                            overflow: hidden
                        }
                    </style>
                </head>
                <body>
                    <script>
                        'use strict'
                        class Map {
                            constructor(width, height) {
                                this.array = []
                                for (let i = 0; i < width * height; i ++) this.array.push(0)
            
                                this.width = width
                                this.height = height
                            }
            
                            generate() {
                                for (let i = 0; i < this.width * this.height; i ++) {
                                    const I = i % this.width
            
                                    if (i % (this.width * 2) < this.width && I % 2 == 0) {
                                        this.array[i] = 1
            
                                        if (i % (this.width * 4) < this.width && I % 4 == 0 ||
                                            (i + this.width * 2) % (this.width * 4) < this.width &&
                                            (I + 2) % 4 == 0) {
                                                const dir = random(0, 4)
            
                                                if (!dir) this.array[i-this.width] = 1
                                                if (dir == 1) this.array[i+1] = 1
                                                if (dir == 2) this.array[i+this.width] = 1
                                                if (dir == 3) this.array[i-1] = 1
                                        }
                                    }
            
            
                                    if (I == 0 || I == this.width - 1 || 
                                        i < this.width || i > this.height * this.width - this.width)
                                            this.array[i] = 1
                                }
                            }
            
                            update() {
                                hero.update()

                                ctx.fillStyle = '#666'
                                this.array.forEach((item, index) => {
                                    if (item) {
                                        const pos = indexToPos(index, this.width)
                                        ctx.strokeRect(
                                            pos.x * scale,
                                            pos.y * scale,
                                            scale,
                                            scale
                                        )
                                    }
                                })
                            }
                        }
            
                        class Player {
                            constructor(x, y) {
                                this.x = x
                                this.y = y
                                this.width = .3
                                this.height = .3

                                this.angle = 0
                            }
            
                            update() {
                                this.angle ++
                                this.draw()
                            }
            
                            draw() {
                                ctx.save()
                                    translate(
                                        .5, .5, this
                                    )
                                    rotate(this.angle)

                                    for (let i = 0; i < ray_amount; i ++) {
                                        const increment = fov / ray_amount
                                        const angle = i * increment - fov / 2

                                        const length = getLength(
                                            angle + this.angle,
                                            this.x + this.width / 2,
                                            this.y + this.height / 2,
                                            view_max
                                        )

                                        ctx.strokeStyle = '#00f'
                                        line(
                                            0, 0, cos(angle) * length,
                                            sin(angle) * length, .1
                                        )
            
                                        ctx.stroke()
                                    }
                                ctx.restore()
                            }
                        }
                        
                        function getLength(angle, start_x, start_y, max_look = 0) {
                            let length = 0
            
                            for (let i = 0; i < max_look; i += ray_accuracy) {
                                length += ray_accuracy
            
                                const x = start_x + cos(angle) * length
                                const y = start_y + sin(angle) * length
            
                                const block = map.array[posToIndex(x, y, map.width)]
            
                                if (block) return i
                            }
            
                            return max_look
                        }
            
                        function collide(obj1, obj2) {
                            return (
                                obj1.x < obj2.x + obj2.width &&
                                obj1.x + obj1.width > obj2.x &&
                                obj1.y < obj2.y + obj2.height &&
                                obj1.y + obj1.height > obj2.y
                            )
                        }
            
                        function rotate(angle) {
                            return ctx.rotate(angle * Math.PI / 180)
                        }
            
                        function cos(angle) {
                            return Math.cos(angle * Math.PI / 180)
                        }
            
                        function sin(angle) {
                            return Math.sin(angle * Math.PI / 180)
                        }
            
                        function indexToPos(index, width) {
                            return {
                                x: index % width,
                                y: ~~(index / width)
                            }
                        }
            
                        function posToIndex(x, y, width) {
                            return Math.floor(x) + Math.floor(y) * width
                        }
            
                        function translate(x, y, obj) {
                            x = x * obj.width
                            y = y * obj.height
                            return ctx.translate(
                                (x + obj.x) * scale,
                                (y + obj.y) * scale
                            )
                        }
            
                        function line(x1, y1, x2, y2, width = 0) {
                            ctx.beginPath()
                            ctx.lineWidth = (width ? width * scale : 1)
                            ctx.moveTo(
                                x1 * scale,
                                y1 * scale
                            )
                            ctx.lineTo(
                                x2 * scale,
                                y2 * scale
                            )
                            ctx.stroke()
                        }
            
                        function setBlockSize() {
                            const screen_division = 1
                            return cvs.height / screen_division / map.height
                        }
            
                        function random(min, max, int = 1) {
                            const value = Math.random() * (max - min) + min
            
                            return int ? Math.floor(value) : value
                        }
            
                        function resize() {
                            cvs.width = innerWidth
                            cvs.height = innerHeight
            
                            scale = setBlockSize()
                        }
            
                        function update() {
                            ctx.clearRect(0, 0, cvs.width, cvs.height)
                            time ++
            
                            map.update()
            
                            requestAnimationFrame(update)
                        }
            
                        const cvs = document.createElement('canvas')
                        const ctx = cvs.getContext('2d')
                        const map = new Map(10, 10)
                        const hero = new Player(5.4, 5.4)
            
                        const view_max = 5
                        const ray_accuracy = .02
                        const ray_amount = 1
                        const fov = 100
            
                        let scale = setBlockSize()
                        let time = 0
            
                        document.body.appendChild(cvs)
                        map.generate()
            
                        addEventListener('resize', resize)
                        resize()
            
                        update()
                    <&sol;script>
                </body>
            </html>
            </script>

            <script type = text id = html><!DOCTYPE html>
    <head>
        <style>
            body {
                background: #fff;
                margin: 0;
                overflow: hidden
            }
        </style>
    </head>
    <body>
        <script>
            'use strict'
            class Map {
                constructor(width, height) {
                    this.array = []
                    for (let i = 0; i < width * height; i ++) this.array.push(0)

                    this.width = width
                    this.height = height
                }

                generate() {
                    for (let i = 0; i < this.width * this.height; i ++) {
                        const I = i % this.width

                        if (i % (this.width * 2) < this.width && I % 2 == 0) {
                            this.array[i] = 1

                            if (i % (this.width * 4) < this.width && I % 4 == 0 ||
                                (i + this.width * 2) % (this.width * 4) < this.width &&
                                (I + 2) % 4 == 0) {
                                    const dir = random(0, 4)

                                    if (!dir) this.array[i-this.width] = 1
                                    if (dir == 1) this.array[i+1] = 1
                                    if (dir == 2) this.array[i+this.width] = 1
                                    if (dir == 3) this.array[i-1] = 1
                            }
                        }


                        if (I == 0 || I == this.width - 1 || 
                            i < this.width || i > this.height * this.width - this.width)
                                this.array[i] = 1
                    }
                }

                update() {
                    hero.update()

                    ctx.fillStyle = '#666'
                    this.array.forEach((item, index) => {
                        if (item) {
                            const pos = indexToPos(index, this.width)
                            ctx.strokeRect(
                                pos.x * scale,
                                pos.y * scale,
                                scale,
                                scale
                            )
                        }
                    })
                }
            }

            class Player {
                constructor(x, y) {
                    this.x = x
                    this.y = y
                    this.width = .3
                    this.height = .3

                    this.angle = 0
                }

                update() {
                    this.angle ++
                    this.draw()
                }

                draw() {
                    ctx.save()
                        translate(
                            .5, .5, this
                        )
                        rotate(this.angle)

                        for (let i = 0; i < ray_amount; i ++) {
                            const increment = fov / ray_amount
                            const angle = i * increment - fov / 2

                            const length = getLength(
                                angle + this.angle,
                                this.x + this.width / 2,
                                this.y + this.height / 2,
                                view_max
                            )

                            ctx.strokeStyle = '#00f'
                            line(
                                0, 0, cos(angle) * length,
                                sin(angle) * length, .03
                            )

                            ctx.stroke()
                        }
                    ctx.restore()
                }
            }
            
            function getLength(angle, start_x, start_y, max_look = 0) {
                let length = 0

                for (let i = 0; i < max_look; i += ray_accuracy) {
                    length += ray_accuracy

                    const x = start_x + cos(angle) * length
                    const y = start_y + sin(angle) * length

                    const block = map.array[posToIndex(x, y, map.width)]

                    if (block) return i
                }

                return max_look
            }

            function collide(obj1, obj2) {
                return (
                    obj1.x < obj2.x + obj2.width &&
                    obj1.x + obj1.width > obj2.x &&
                    obj1.y < obj2.y + obj2.height &&
                    obj1.y + obj1.height > obj2.y
                )
            }

            function rotate(angle) {
                return ctx.rotate(angle * Math.PI / 180)
            }

            function cos(angle) {
                return Math.cos(angle * Math.PI / 180)
            }

            function sin(angle) {
                return Math.sin(angle * Math.PI / 180)
            }

            function indexToPos(index, width) {
                return {
                    x: index % width,
                    y: ~~(index / width)
                }
            }

            function posToIndex(x, y, width) {
                return Math.floor(x) + Math.floor(y) * width
            }

            function translate(x, y, obj) {
                x = x * obj.width
                y = y * obj.height
                return ctx.translate(
                    (x + obj.x) * scale,
                    (y + obj.y) * scale
                )
            }

            function line(x1, y1, x2, y2, width = 0) {
                ctx.beginPath()
                ctx.lineWidth = (width ? width * scale : 1)
                ctx.moveTo(
                    x1 * scale,
                    y1 * scale
                )
                ctx.lineTo(
                    x2 * scale,
                    y2 * scale
                )
                ctx.stroke()
            }

            function setBlockSize() {
                const screen_division = 1
                return cvs.height / screen_division / map.height
            }

            function random(min, max, int = 1) {
                const value = Math.random() * (max - min) + min

                return int ? Math.floor(value) : value
            }

            function resize() {
                cvs.width = innerWidth
                cvs.height = innerHeight

                scale = setBlockSize()
            }

            function update() {
                ctx.clearRect(0, 0, cvs.width, cvs.height)
                time ++

                map.update()

                requestAnimationFrame(update)
            }

            const cvs = document.createElement('canvas')
            const ctx = cvs.getContext('2d')
            const map = new Map(10, 10)
            const hero = new Player(5.4, 5.4)

            const view_max = 5
            const ray_accuracy = .02
            const ray_amount = 10
            const fov = 100

            let scale = setBlockSize()
            let time = 0

            document.body.appendChild(cvs)
            map.generate()

            addEventListener('resize', resize)
            resize()

            update()
        <&sol;script>
    </body>
</html>
            </script>

            <script type = text id = html><!DOCTYPE html>
    <head>
        <style>
            body {
                background: #fff;
                margin: 0;
                overflow: hidden
            }
        </style>
    </head>
    <body>
        <script>
            'use strict'
            class Map {
                constructor(width, height) {
                    this.array = []
                    for (let i = 0; i < width * height; i ++) this.array.push(0)

                    this.width = width
                    this.height = height
                }

                generate() {
                    for (let i = 0; i < this.width * this.height; i ++) {
                        const I = i % this.width

                        if (i % (this.width * 2) < this.width && I % 2 == 0) {
                            this.array[i] = 1

                            if (i % (this.width * 4) < this.width && I % 4 == 0 ||
                                (i + this.width * 2) % (this.width * 4) < this.width &&
                                (I + 2) % 4 == 0) {
                                    const dir = random(0, 4)

                                    if (!dir) this.array[i-this.width] = 1
                                    if (dir == 1) this.array[i+1] = 1
                                    if (dir == 2) this.array[i+this.width] = 1
                                    if (dir == 3) this.array[i-1] = 1
                            }
                        }


                        if (I == 0 || I == this.width - 1 || 
                            i < this.width || i > this.height * this.width - this.width)
                                this.array[i] = 1
                    }
                }

                update() {
                    hero.update()
                }
            }

            class Player {
                constructor(x, y) {
                    this.x = x
                    this.y = y
                    this.width = .3
                    this.height = .3

                    this.angle = 0
                }

                update() {
                    this.angle ++
                    this.draw()
                }

                draw() {
                    for (let i = 0; i < ray_amount; i ++) {
                        const increment = fov / ray_amount
                        const angle = i * increment - fov / 2

                        const length = getLength(
                            angle + hero.angle,
                            hero.x + hero.width / 2,
                            hero.y + hero.height / 2,
                            view_max
                        )

                        const height = ((50 / length) * cvs.width) / 600
                        const shade = 50 / length

                        const segment_width = Math.floor(cvs.width / 20) + 1

                        ctx.fillStyle = 'rgb(' +
                            shade + ',' +
                            shade + ',' +
                            shade / 2 + ',' +
                            (view_max - length) * 50 +
                        ')'
                        ctx.fillRect(
                            i * segment_width,
                            cvs.height / 2 + height / 2,
                            segment_width,
                            -height
                        )
                    }
                }
            }
            
            function getLength(angle, start_x, start_y, max_look = 0) {
                let length = 0

                for (let i = 0; i < max_look; i += ray_accuracy) {
                    length += ray_accuracy

                    const x = start_x + cos(angle) * length
                    const y = start_y + sin(angle) * length

                    const block = map.array[posToIndex(x, y, map.width)]

                    if (block) return i
                }

                return max_look
            }

            function cos(angle) {
                return Math.cos(angle * Math.PI / 180)
            }

            function sin(angle) {
                return Math.sin(angle * Math.PI / 180)
            }

            function posToIndex(x, y, width) {
                return Math.floor(x) + Math.floor(y) * width
            }

            function random(min, max, int = 1) {
                const value = Math.random() * (max - min) + min

                return int ? Math.floor(value) : value
            }

            function resize() {
                cvs.width = innerWidth
                cvs.height = innerHeight
            }

            function update() {
                ctx.clearRect(0, 0, cvs.width, cvs.height)
                time ++

                map.update()

                requestAnimationFrame(update)
            }

            const cvs = document.createElement('canvas')
            const ctx = cvs.getContext('2d')
            const map = new Map(10, 10)
            const hero = new Player(5.4, 5.4)

            const view_max = 5
            const ray_accuracy = .02
            const ray_amount = 1
            const fov = 100

            let time = 0

            document.body.appendChild(cvs)
            map.generate()

            addEventListener('resize', resize)
            resize()

            update()
        <&sol;script>
    </body>
</html>
            </script>

            <script type = text id = html><!DOCTYPE html>
    <head>
        <style>
            body {
                background: #fff;
                margin: 0;
                overflow: hidden
            }
        </style>
    </head>
    <body>
        <script>
            'use strict'
            class Map {
                constructor(width, height) {
                    this.array = []
                    for (let i = 0; i < width * height; i ++) this.array.push(0)

                    this.width = width
                    this.height = height
                }

                generate() {
                    for (let i = 0; i < this.width * this.height; i ++) {
                        const I = i % this.width

                        if (i % (this.width * 2) < this.width && I % 2 == 0) {
                            this.array[i] = 1

                            if (i % (this.width * 4) < this.width && I % 4 == 0 ||
                                (i + this.width * 2) % (this.width * 4) < this.width &&
                                (I + 2) % 4 == 0) {
                                    const dir = random(0, 4)

                                    if (!dir) this.array[i-this.width] = 1
                                    if (dir == 1) this.array[i+1] = 1
                                    if (dir == 2) this.array[i+this.width] = 1
                                    if (dir == 3) this.array[i-1] = 1
                            }
                        }


                        if (I == 0 || I == this.width - 1 || 
                            i < this.width || i > this.height * this.width - this.width)
                                this.array[i] = 1
                    }
                }

                update() {
                    hero.update()
                }
            }

            class Player {
                constructor(x, y) {
                    this.x = x
                    this.y = y
                    this.width = .3
                    this.height = .3

                    this.angle = 0
                }

                update() {
                    this.angle ++
                    this.draw()
                }

                draw() {
                    for (let i = 0; i < ray_amount; i ++) {
                        const increment = fov / ray_amount
                        const angle = i * increment - fov / 2

                        const length = getLength(
                            angle + hero.angle,
                            hero.x + hero.width / 2,
                            hero.y + hero.height / 2,
                            view_max
                        )

                        const height = ((100 / length) * cvs.width) / 500
                        const shade = 50 / length

                        const segment_width = Math.floor(cvs.width / ray_amount) + 1

                        ctx.fillStyle = 'rgb(' +
                            shade + ',' +
                            shade + ',' +
                            shade / 2 + ',' +
                            (view_max - length) * 50 +
                        ')'
                        ctx.fillRect(
                            i * segment_width,
                            cvs.height / 2 + height / 2,
                            segment_width,
                            -height
                        )
                    }
                }
            }
            
            function getLength(angle, start_x, start_y, max_look = 0) {
                let length = 0

                for (let i = 0; i < max_look; i += ray_accuracy) {
                    length += ray_accuracy

                    const x = start_x + cos(angle) * length
                    const y = start_y + sin(angle) * length

                    const block = map.array[posToIndex(x, y, map.width)]

                    if (block) return i
                }

                return max_look
            }

            function cos(angle) {
                return Math.cos(angle * Math.PI / 180)
            }

            function sin(angle) {
                return Math.sin(angle * Math.PI / 180)
            }

            function posToIndex(x, y, width) {
                return Math.floor(x) + Math.floor(y) * width
            }

            function random(min, max, int = 1) {
                const value = Math.random() * (max - min) + min

                return int ? Math.floor(value) : value
            }

            function resize() {
                cvs.width = innerWidth
                cvs.height = innerHeight
            }

            function update() {
                ctx.clearRect(0, 0, cvs.width, cvs.height)
                time ++

                map.update()

                requestAnimationFrame(update)
            }

            const cvs = document.createElement('canvas')
            const ctx = cvs.getContext('2d')
            const map = new Map(10, 10)
            const hero = new Player(5.4, 5.4)

            const view_max = 5
            const ray_accuracy = .02
            const ray_amount = Math.round(cvs.width/20)
            const fov = 100
            let time = 0

            document.body.appendChild(cvs)
            map.generate()

            addEventListener('resize', resize)
            resize()

            update()
        <&sol;script>
    </body>
</html>
            </script>

            <script type = text id = html><!DOCTYPE html>
    <head>
        <style>
            body {
                background: #fff;
                margin: 0;
                overflow: hidden
            }
        </style>
    </head>
    <body>
        <script>
            'use strict'
            class Map {
                constructor(width, height) {
                    this.array = []
                    for (let i = 0; i < width * height; i ++) this.array.push(0)

                    this.width = width
                    this.height = height
                }

                generate() {
                    for (let i = 0; i < this.width * this.height; i ++) {
                        const I = i % this.width

                        if (i % (this.width * 2) < this.width && I % 2 == 0) {
                            this.array[i] = 1

                            if (i % (this.width * 4) < this.width && I % 4 == 0 ||
                                (i + this.width * 2) % (this.width * 4) < this.width &&
                                (I + 2) % 4 == 0) {
                                    const dir = random(0, 4)

                                    if (!dir) this.array[i-this.width] = 1
                                    if (dir == 1) this.array[i+1] = 1
                                    if (dir == 2) this.array[i+this.width] = 1
                                    if (dir == 3) this.array[i-1] = 1
                            }
                        }


                        if (I == 0 || I == this.width - 1 || 
                            i < this.width || i > this.height * this.width - this.width)
                                this.array[i] = 1
                    }
                }

                update() {
                    hero.update()
                }
            }

            class Player {
                constructor(x, y) {
                    this.x = x
                    this.y = y
                    this.width = .3
                    this.height = .3

                    this.angle = 0
                }

                update() {
                    this.angle ++
                    this.draw()
                }

                draw() {
                    for (let i = 0; i < ray_amount; i ++) {
                        // get the angle of each ray
                        const increment = fov / ray_amount
                        const angle = i * increment - fov / 2

                        // get the length of the ray
                        const length = getLength(
                            angle + hero.angle,
                            hero.x + hero.width / 2,
                            hero.y + hero.height / 2,
                            view_max
                        )

                        // get the height of the rectangle based on the rays length
                        const height = ((100 / length) * cvs.width) / 500

                        // get the colour of the rectangle based on the rays length
                        const shade = 50 / length

                        /* calculate the width of each rectangle (or segment)
                        based off the amount of rays and the width of the screen */
                        const segment_width = Math.floor(cvs.width / ray_amount) + 1

                        ctx.fillStyle = 'rgb(' +
                            shade + ',' +
                            shade + ',' +
                            shade / 2 + ',' +
                            (view_max - length) * 50 +
                        ')'
                        ctx.fillRect(
                            i * segment_width,
                            cvs.height / 2 + height / 2,
                            segment_width,
                            -height
                        )
                    }
                }
            }
            
            function getLength(angle, start_x, start_y, max_look = 0) {
                let length = 0

                for (let i = 0; i < max_look; i += ray_accuracy) {
                    length += ray_accuracy

                    const x = start_x + cos(angle) * length
                    const y = start_y + sin(angle) * length

                    const block = map.array[posToIndex(x, y, map.width)]

                    if (block) return i
                }

                return max_look
            }

            function collide(obj1, obj2) {
                return (
                    obj1.x < obj2.x + obj2.width &&
                    obj1.x + obj1.width > obj2.x &&
                    obj1.y < obj2.y + obj2.height &&
                    obj1.y + obj1.height > obj2.y
                )
            }

            function cos(angle) {
                return Math.cos(angle * Math.PI / 180)
            }

            function sin(angle) {
                return Math.sin(angle * Math.PI / 180)
            }

            function posToIndex(x, y, width) {
                return Math.floor(x) + Math.floor(y) * width
            }

            function random(min, max, int = 1) {
                const value = Math.random() * (max - min) + min

                return int ? Math.floor(value) : value
            }

            function resize() {
                cvs.width = innerWidth
                cvs.height = innerHeight
            }

            function update() {
                ctx.clearRect(0, 0, cvs.width, cvs.height)
                time ++

                map.update()

                requestAnimationFrame(update)
            }

            const cvs = document.createElement('canvas')
            const ctx = cvs.getContext('2d')
            const map = new Map(10, 10)
            const hero = new Player(5.4, 5.4)

            const view_max = 5
            const ray_accuracy = .02
            const ray_amount = Math.round(cvs.width)
            const fov = 100

            let time = 0

            document.body.appendChild(cvs)
            map.generate()

            addEventListener('resize', resize)
            resize()

            update()
        <&sol;script>
    </body>
</html>
            </script>

            A small project developed throughout March 2022<br>
            Use the <mark>Arrows / WASD / ZQSD</mark> to move around a procedural 1000x1000 city.
            <p></p>
            Here is the complete source code:
            <pre class = code id = 0></pre>
            This experiment was fun to make, but also, as I began trying to add more
            features I realised that ray casting, great as it is, is very limited and tricky
            to grow from. <span class = italic>'It is what it is'</span>, so to speak.<br>
            The concept of a ray-caster is very simple.
            Although it may appear to look 3D, it is actually using 2D logic to project
            various 'things' onto a canvas in such a manner that it looks 3D.
            <p></p>
            This is a ray.
            <div class = iframe id = 1></div>
            <p></p>
            ...And these are some rectangles.
            <div class = iframe id = 2></div>
            <p></p>
            If you make collision with the ray and the rectangles...
            <div class = iframe id = 3></div>
            <p></p>
            ...and add multiple rays within a limit,
            you have the base structure for the 3D casting.
            <div class = iframe id = 4></div>
            <p></p>
            So, take the ray on the far left.<br>
            That ray has a unique length based on what it's colliding with.
            If you drew a rectangle on the far left of a canvas,
            and its height corresponded to the length of the ray
            (the longer the ray, the shorter the rectangle),
            you would have actually completed the main part of ray-casting.
            <p></p>
            This:
            <div class = iframe id = 3></div>
            <p></p>
            ...would become this:
            <div class = iframe id = 5></div>
            ...And with more rays it would become this:
            <div class = iframe id = 6></div>
            <p></p>
            As you can see, its looking a <span class = italic>bit</span> 3D,
            but at the moment it's not very believable.
            <p></p>
            However, if a higher resolution is added
            (i.e. adding a ray for every ~pixel),
            this would be the result:
            <div class = iframe id = 7></div>
            This is the source code for the demo above:
            <pre class = code id = 7></pre>
        </section>

        <span class = copyright>
             Copyright <span class = year></span>
            Joachimford.uk  <a href = mailto:contact@joachimford.uk>contact@joachimford.uk</a>
        </span>
    </body>
</html>